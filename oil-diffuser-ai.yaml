blueprint:
  name: Oil Diffuser Ai
  description: |
    ![OilDiffuser](https://raw.githubusercontent.com/zodyking/oil-diffuser-blueprint/refs/heads/main/ChatGPT%20Image%20Oct%2018%2C%202025%2C%2007_21_16%20PM.png)

    Control a waterless oil diffuser via a smart outlet with **two independent modes** that can run at the same time:
    • Duty cycle — run a cycle every X minutes; keep ON for Y minutes  
    • Presence — when the presence sensor turns ON, keep ON for Z minutes  
    Optional TTS before ON and a safety max-runtime cutoff.
  domain: automation
  author: chat.openai.com/@gpt

  input:
    # ---- Core entities (ordered) ----
    outlet_switch:
      name: Diffuser outlet
      description: "Select the smart outlet that powers the diffuser."
      selector:
        entity:
          domain: switch

    presence_sensor:
      name: Presence / motion sensor
      description: "Binary_sensor that reports occupancy/motion. Fires when state becomes 'on'."
      selector:
        entity:
          domain: binary_sensor
          device_class:
            - occupancy
            - motion

    # ---- Mode toggles (ordered) ----
    duty_enabled:
      name: Duty cycle enabled
      description: "Run a cycle every X minutes."
      default: true
      selector:
        boolean: {}

    presence_enabled:
      name: Presence mode enabled
      description: "Turn ON when the presence sensor goes to 'on'."
      default: true
      selector:
        boolean: {}

    # ---- Duty cycle settings ----
    duty_interval_minutes:
      name: Cycle interval (minutes)
      description: "How often to start a cycle."
      default: 30
      selector:
        number:
          min: 1
          max: 1440
          step: 1
          unit_of_measurement: min

    duty_on_duration:
      name: On-time per cycle
      description: "How long to keep the outlet ON each cycle."
      default:
        hours: 0
        minutes: 8
        seconds: 0
      selector:
        duration: {}

    # ---- Presence settings ----
    presence_on_duration:
      name: Presence on-time
      description: "How long to keep the outlet ON after presence is detected."
      default:
        hours: 0
        minutes: 20
        seconds: 0
      selector:
        duration: {}

    # ---- TTS (Aqara-style plumbing) ----
    tts_enabled:
      name: TTS announcement before turning ON
      description: "Speaks a short message using the outlet's Area name."
      default: false
      selector:
        boolean: {}

    tts_engine:
      name: TTS engine
      description: "Pick your TTS engine entity (e.g., tts.piper). Required if TTS is enabled."
      default: ""
      selector:
        entity:
          domain: tts

    tts_media_players:
      name: Speakers for TTS
      description: "One or more media_player entities to speak on."
      default: []
      selector:
        entity:
          domain: media_player
          multiple: true

    tts_cache:
      name: Cache TTS audio
      description: "Let Home Assistant cache synthesized speech when supported."
      default: false
      selector:
        boolean: {}

    tts_voice:
      name: Voice name (optional)
      description: "If supported by your TTS provider (options.voice). Leave blank for default."
      default: ""
      selector:
        text: {}

    tts_preroll_ms:
      name: TTS pre-roll (milliseconds)
      description: "Short delay before speaking to avoid clipping the start of the message."
      default: 150
      selector:
        number:
          min: 0
          max: 300
          step: 10
          unit_of_measurement: ms

    # ---- Safety ----
    max_runtime:
      name: Safety cutoff — max ON runtime
      description: "If the outlet stays ON this long for any reason, force OFF."
      default:
        hours: 2
        minutes: 0
        seconds: 0
      selector:
        duration: {}

# Allow presence to run immediately even if a duty cycle is mid-delay
mode: parallel
max: 10
max_exceeded: silent

# ---------------- Variables ----------------
variables:
  v_switch: !input outlet_switch

  # Duty
  duty_enabled: !input duty_enabled
  v_interval: !input duty_interval_minutes
  v_duty_dur: !input duty_on_duration

  # Presence
  presence_enabled: !input presence_enabled
  v_presence: !input presence_sensor
  v_presence_dur: !input presence_on_duration

  # TTS (Aqara-style)
  speak_enabled: !input tts_enabled
  tts_engine_ent: !input tts_engine
  players: !input tts_media_players
  tts_cache: !input tts_cache
  tts_voice_name: !input tts_voice
  tts_preroll_ms: !input tts_preroll_ms

  # Can we speak at all?
  has_tts: >-
    {{ speak_enabled
       and (players | length > 0)
       and (tts_engine_ent is string and tts_engine_ent | length > 0) }}

  # Auto message from Area name (fallback to "the room")
  v_msg: >-
    {% set area = area_name(v_switch) %}
    {{ 'Freshening up ' ~ (area if area else 'the room') ~ '.' }}

# ---------------- Triggers ----------------
trigger:
  # Duty-cycle tick: evaluate every minute; branch checks enable & interval
  - id: duty_tick
    platform: time_pattern
    minutes: "/1"

  # Presence ON — reliable: any previous state -> "on"
  - id: presence_on
    platform: state
    entity_id: !input presence_sensor
    to: "on"

  # Safety cutoff
  - id: safety_cutoff
    platform: state
    entity_id: !input outlet_switch
    to: "on"
    for: !input max_runtime

condition: []

# ---------------- Actions ----------------
action:
  - variables:
      # recompute per-run in case Areas change
      v_msg_now: >-
        {% set area = area_name(v_switch) %}
        {{ 'Freshening up ' ~ (area if area else 'the room') ~ '.' }}

  - choose:

      # ---- Duty cycle (independent, non-interfering) ----
      - conditions:
          - condition: trigger
            id: duty_tick
          - condition: template
            value_template: "{{ duty_enabled }}"
          - condition: template
            value_template: >-
              {% set iv = (v_interval | int(1)) %}
              {{ ((as_timestamp(now()) | int // 60) % iv) == 0 }}
        sequence:
          - variables:
              sw_was_on: "{{ is_state(v_switch, 'on') }}"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ has_tts and not sw_was_on }}"
                sequence:
                  - delay:
                      milliseconds: "{{ tts_preroll_ms | int }}"
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ (tts_voice_name | trim) != '' }}"
                        sequence:
                          - service: tts.speak
                            target:
                              entity_id: !input tts_engine
                            data:
                              message: "{{ v_msg_now }}"
                              cache: !input tts_cache
                              media_player_entity_id: !input tts_media_players
                              options:
                                voice: "{{ tts_voice_name }}"
                    default:
                      - service: tts.speak
                        target:
                          entity_id: !input tts_engine
                        data:
                          message: "{{ v_msg_now }}"
                          cache: !input tts_cache
                          media_player_entity_id: !input tts_media_players
            default: []
          - service: switch.turn_on
            target:
              entity_id: !input outlet_switch
          - delay: !input duty_on_duration
          - if:
              - condition: state
                entity_id: !input outlet_switch
                state: "on"
              - condition: template
                value_template: "{{ not sw_was_on }}"
            then:
              - service: switch.turn_off
                target:
                  entity_id: !input outlet_switch

      # ---- Presence (independent, non-interfering) ----
      - conditions:
          - condition: trigger
            id: presence_on
          - condition: template
            value_template: "{{ presence_enabled }}"
        sequence:
          - variables:
              sw_was_on: "{{ is_state(v_switch, 'on') }}"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ has_tts and not sw_was_on }}"
                sequence:
                  - delay:
                      milliseconds: "{{ tts_preroll_ms | int }}"
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ (tts_voice_name | trim) != '' }}"
                        sequence:
                          - service: tts.speak
                            target:
                              entity_id: !input tts_engine
                            data:
                              message: "{{ v_msg_now }}"
                              cache: !input tts_cache
                              media_player_entity_id: !input tts_media_players
                              options:
                                voice: "{{ tts_voice_name }}"
                    default:
                      - service: tts.speak
                        target:
                          entity_id: !input tts_engine
                        data:
                          message: "{{ v_msg_now }}"
                          cache: !input tts_cache
                          media_player_entity_id: !input tts_media_players
            default: []
          - service: switch.turn_on
            target:
              entity_id: !input outlet_switch
          - delay: !input presence_on_duration
          - if:
              - condition: state
                entity_id: !input outlet_switch
                state: "on"
              - condition: template
                value_template: "{{ not sw_was_on }}"
            then:
              - service: switch.turn_off
                target:
                  entity_id: !input outlet_switch

      # ---- Safety cutoff ----
      - conditions:
          - condition: trigger
            id: safety_cutoff
        sequence:
          - service: switch.turn_off
            target:
              entity_id: !input outlet_switch
          - service: logbook.log
            data:
              name: Diffuser Safety
              message: "Turned OFF after reaching max runtime."
              entity_id: !input outlet_switch

  - stop: "Done"
